name: Build, Push to ECR and Deploy to EC2

on:
  push:
    branches: [ "main", "develop" ]
    tags: [ "v*" ]

env:
  AWS_REGION: sa-east-1
  # Base name for your ECR repositories (two repos will be used: "-web" and "-frontend")
  ECR_REPOSITORY: nft-portal

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write    # to use OIDC if configured
      packages: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Ensure ECR repositories exist
        shell: bash
        run: |
          set -e
          for repo in "${ECR_REPOSITORY}-web" "${ECR_REPOSITORY}-frontend"; do
            if ! aws ecr describe-repositories --repository-names "$repo" >/dev/null 2>&1; then
              aws ecr create-repository --repository-name "$repo" >/dev/null
              echo "Created ECR repo: $repo"
            else
              echo "ECR repo exists: $repo"
            fi
          done

      - name: Log in to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set image tags
        id: vars
        run: |
          echo "sha=${GITHUB_SHA}" >> $GITHUB_OUTPUT
          echo "registry=${{ steps.login-ecr.outputs.registry }}" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push backend image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: docker/Dockerfile
          push: true
          tags: |
            ${{ steps.vars.outputs.registry }}/${{ env.ECR_REPOSITORY }}-web:${{ steps.vars.outputs.sha }}
            ${{ steps.vars.outputs.registry }}/${{ env.ECR_REPOSITORY }}-web:latest
          labels: |
            org.opencontainers.image.source=${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}

      - name: Build and push frontend image (dist publisher)
        uses: docker/build-push-action@v6
        with:
          context: ./frontend
          file: frontend/Dockerfile
          target: build
          push: true
          build-args: |
            VITE_API_BASE_URL=https://api.nftmarketplace.com.br
          tags: |
            ${{ steps.vars.outputs.registry }}/${{ env.ECR_REPOSITORY }}-frontend:${{ steps.vars.outputs.sha }}
            ${{ steps.vars.outputs.registry }}/${{ env.ECR_REPOSITORY }}-frontend:latest
          labels: |
            org.opencontainers.image.source=${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}

      - name: Copy compose and nginx config to EC2
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          # Comma-separated patterns to avoid empty tar issue
          source: "docker/docker-compose.prod.yml,docker/nginx/nginx.conf,docker/nginx/nginx.ssl.conf"
          # Upload to a user-writable absolute location; we'll move with sudo in the next step
          target: /home/${{ secrets.EC2_USER }}/.nft_portal_upload

      - name: Get ECR login password (runner)
        id: ecrpass
        run: echo "password=$(aws ecr get-login-password --region $AWS_REGION)" >> $GITHUB_OUTPUT

      - name: Deploy on EC2 (pull images and restart)
        uses: appleboy/ssh-action@v1.1.0
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          port: 22
          script_stop: true
          script: |
            set -e
            # Inject environment from runner
            ECR_REGISTRY="${{ steps.login-ecr.outputs.registry }}"
            ECR_REPOSITORY="${{ env.ECR_REPOSITORY }}"
            TAG="${{ steps.vars.outputs.sha }}"
            AWS_REGION="${{ env.AWS_REGION }}"
            ECR_PASSWORD="${{ steps.ecrpass.outputs.password }}"
            UPLOAD_DIR="$HOME/.nft_portal_upload"
            # Prepare target directories
            sudo mkdir -p /opt/nft_portal/docker/nginx
            # Copy uploaded files into /opt with sudo
            if [ -f "$UPLOAD_DIR/docker/docker-compose.prod.yml" ]; then
              sudo cp -f "$UPLOAD_DIR/docker/docker-compose.prod.yml" /opt/nft_portal/docker/docker-compose.prod.yml
            else
              echo "ERROR: compose file not found at $UPLOAD_DIR/docker/docker-compose.prod.yml" >&2
            fi
            if [ -f "$UPLOAD_DIR/docker/nginx/nginx.conf" ]; then
              sudo cp -f "$UPLOAD_DIR/docker/nginx/nginx.conf" /opt/nft_portal/docker/nginx/nginx.conf
            else
              echo "ERROR: nginx.conf not found at $UPLOAD_DIR/docker/nginx/nginx.conf" >&2
            fi
            if [ -f "$UPLOAD_DIR/docker/nginx/nginx.ssl.conf" ]; then
              sudo cp -f "$UPLOAD_DIR/docker/nginx/nginx.ssl.conf" /opt/nft_portal/docker/nginx/nginx.ssl.conf
            else
              echo "WARNING: nginx.ssl.conf not found at $UPLOAD_DIR/docker/nginx/nginx.ssl.conf" >&2
            fi
            # Cleanup upload dir
            rm -rf "$UPLOAD_DIR"

            # Verify application .env exists (used by services)
            if [ ! -f /opt/nft_portal/.env ]; then
              echo "ERROR: /opt/nft_portal/.env missing. Create it with Django/DB/Redis settings and rerun."
              exit 1
            fi

            cd /opt/nft_portal
            # Login to ECR using password from runner (no awscli required on EC2)
            echo "${ECR_PASSWORD}" | sudo docker login --username AWS --password-stdin "${ECR_REGISTRY}"

            # Pull and start updated services
            sudo env ECR_REGISTRY="$ECR_REGISTRY" ECR_REPOSITORY="$ECR_REPOSITORY" TAG="$TAG" \
              docker compose -f docker/docker-compose.prod.yml pull
            sudo env ECR_REGISTRY="$ECR_REGISTRY" ECR_REPOSITORY="$ECR_REPOSITORY" TAG="$TAG" \
              docker compose -f docker/docker-compose.prod.yml up -d
            echo "[DEPLOY] docker compose up -d completed"
            # Be tolerant for the remaining post-up steps so incidental non-zero exits don't fail the job
            set +e
            # Obtain/renew Let's Encrypt certificate (requires LE_EMAIL in /opt/nft_portal/.env)
            # Use sed to extract the value safely; avoids non-zero grep exit under 'set -e' when not present
            LE_EMAIL=$(sed -n 's/^LE_EMAIL=//p' /opt/nft_portal/.env)
            if [ -z "$LE_EMAIL" ]; then
              echo "WARNING: LE_EMAIL not set in /opt/nft_portal/.env. Skipping certificate issuance."
            else
              echo "[DEPLOY] Starting certbot issuance via webroot"
              set +e
              # Ensure nginx is serving ACME webroot on 80 first (already running with non-SSL config)
              sudo env ECR_REGISTRY="$ECR_REGISTRY" ECR_REPOSITORY="$ECR_REPOSITORY" TAG="$TAG" \
                docker compose -f docker/docker-compose.prod.yml run --rm certbot \
                certbot certonly --non-interactive --agree-tos --no-eff-email \
                  --email "$LE_EMAIL" --webroot -w /var/www/certbot \
                  -d nftmarketplace.com.br -d www.nftmarketplace.com.br -d api.nftmarketplace.com.br || true
              # If cert exists, switch nginx to SSL config and reload
              if sudo test -f /var/lib/docker/volumes/docker_letsencrypt/_data/live/nftmarketplace.com.br/fullchain.pem; then
                sudo cp -f /opt/nft_portal/docker/nginx/nginx.ssl.conf /opt/nft_portal/docker/nginx/nginx.conf
                sudo docker compose -f docker/docker-compose.prod.yml exec -T nginx nginx -s reload || sudo docker compose -f docker/docker-compose.prod.yml restart nginx || true
                echo "[DEPLOY] Nginx reloaded with SSL config"
              else
                echo "WARNING: Certificate not found. Keeping HTTP-only config."
              fi
              set -e
            fi
            # Optional cleanup
            sudo docker image prune -f || true
            echo "[DEPLOY] finished"
            exit 0
